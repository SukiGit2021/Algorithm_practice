1. Palindrome Linked List (#234)
2. Lowest Common Ancestor of a Binary Search Tree (#235)
3. Delete Node in a Linked List (#237)
4. Valid Anagram (#242)
5. Binary Tree Paths (#257)




Jane:
1. 
创建一个vals list，把linked list的每个val都放进去，返回vals == vals[::-1]
2.
若pq都大于root，root右移；若pq都小于root，root左移；直到root位于pq中间
3. 
不删去当前node，而是把node当作下一个点，删去下一个点
step1: change the node value to the next node value
step2: change the node next to the next node next
4. 
dict
5.
注意：此处返回的是从root到leaf的完整路径。和传统的dfs稍有不同，每次需要把（下一节点和完整路径）同时存入stack



Suki:

1. 遍历所有head然后对比 nodes == nodes[::-1]
2. root大于p,q的时候左移， 小于的时候右移。
3. node = node.next  node.next = node.next.next
4. 
method1: 双字典 container_s == container_t
method2: list存储char，排序后比较list是否相等
method3: 计数器 Counter(s) == Counter(t)
5. 从root开始，一直走到没有left node和right node为一个阶段。


Any comment:
